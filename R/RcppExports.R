# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Mendell-Elston approximation to multivariate Gaussian CDF.
#' @description
#' The function computes the  CDF for a multivariate Gaussian distribution approximated according to the method of Mendell-Elston.
#' @param x
#' nx1 vector of point to evaluate the CDF at.
#' @param r
#' nxn correlation matrix.
#' @return
#' double; log of probability.
#' @keywords internal
#'
ME <- function(x, r) {
    .Call(`_Rprobit_ME`, x, r)
}

#' Gradient calculation for Mendell-Elston approximation to multivariate Gaussian CDF.
#' @description
#' The function computes the gradient of the CDF for a multivariate Gaussian distribution approximated according to the method of Mendell-Elston.
#' @param x
#' nx1 vector of point to evaluate the CDF at.
#' @param r
#' nxn correlation matrix.
#' @return
#' vector; gradient of log of probability.
#' @keywords internal
#'
dlcond_ME <- function(x, r) {
    .Call(`_Rprobit_dlcond_ME`, x, r)
}

#' Hessian for Mendell-Elston approximation to multivariate Gaussian CDF.
#' @description
#' The function computes the Hessian of the CDF for a multivariate Gaussian distribution approximated according to the method of Mendell-Elston.
#' @param x
#' nx1 vector of point to evaluate the CDF at.
#' @param r
#' nxn correlation matrix.
#' @return
#' Matrix; Hessian of log of probability.
#' @keywords internal
ME_hess_new <- function(x, r) {
    .Call(`_Rprobit_ME_hess_new`, x, r)
}

#' Solow-Joe approximation to multivariate Gaussian CDF.
#' @description
#' The function computes the  CDF for a multivariate Gaussian distribution according to the method of Solow-Joe.
#' @param x
#' nx1 vector of point to evaluate the CDF at.
#' @param r
#' nxn correlation matrix.
#' @return
#' double; log of probability.
#' @keywords internal
#'
SJ <- function(x, r) {
    .Call(`_Rprobit_SJ`, x, r)
}

#' Solow-Joe approximation to multivariate Gaussian CDF: gradient calculation
#' @description
#' The function computes the gradient of the CDF for a multivariate Gaussian distribution according to the method of Solow-Joe.
#' @param x
#' nx1 vector of point to evaluate the CDF at.
#' @param r
#' nxn correlation matrix.
#' @return
#' vector; gradient of log of probability.
#' @keywords internal
#'
dlcond <- function(x, r) {
    .Call(`_Rprobit_dlcond`, x, r)
}

#' Hessian of Solow-Joe approximation to multivariate Gaussian CDF.
#' @description
#' The function computes the Hessian of the  CDF for a multivariate Gaussian distribution according to the method of Solow-Joe.
#' @param x
#' nx1 vector of point to evaluate the CDF at.
#' @param r
#' nxn correlation matrix.
#' @return
#' matrix; Hessian of log of probability.
#' @keywords internal
#'
SJ_hess_new <- function(x, r) {
    .Call(`_Rprobit_SJ_hess_new`, x, r)
}

#' TVBS approximation to multivariate Gaussian CDF. 
#' @description
#' The function computes the  CDF for a multivariate Gaussian distribution according to the method of Chandra Bhat (TVBS) as well as the gradient. 
#' @param x_norm
#' nx1 vector of point to evaluate the CDF at. 
#' @param Cor_mat
#' nxn correlation matrix.
#' @param log_out
#' integer; probability or log of probability? 
#' @return 
#' double; (log of) probability. 
#' @keywords internal
#'
TVBS <- function(x_norm, Cor_mat, log_out = 0L) {
    .Call(`_Rprobit_TVBS`, x_norm, Cor_mat, log_out)
}

#' TVBS approximation to multivariate Gaussian CDF. 
#' @description
#' The function computes the  CDF for a multivariate Gaussian distribution according to the method of Chandra Bhat (TVBS). 
#' @param x_norm
#' nx1 vector of point to evaluate the CDF at. 
#' @param Cor_mat
#' nxn correlation matrix.
#' @param log_out
#' integer; probability or log of probability? 
#' @return 
#' double; (log of) probability. 
#' @keywords internal
#'
TVBS_p <- function(x_norm, Cor_mat, log_out = 0L) {
    .Call(`_Rprobit_TVBS_p`, x_norm, Cor_mat, log_out)
}

#' multivariate Gaussian CDF: calculates CDF up to four dimensions
#' @description
#' The function computes the  Gaussian CDF for 1, 2, 3 and four dimensional problems. 
#' @param upper
#' nx1 vector of points where to evaluate 
#' @param mu
#' nx1 vector; expectation
#' @param Sigma
#' nxn correlation matrix.
#' @return 
#' vector; gradient of log probability, double; (log of) probability. 
#' @keywords internal
#'
TVBS_pmvnorm_cpp <- function(upper, mu, Sigma) {
    .Call(`_Rprobit_TVBS_pmvnorm_cpp`, upper, mu, Sigma)
}

#' TVBS approximation to multivariate Gaussian CDF. 
#' @description
#' The function computes the  CDF for a multivariate Gaussian distribution according to the method of Chandra Bhat (TVBS). 
#' @param x_norm
#' nx1 vector of point to evaluate the CDF at. 
#' @param Cor_mat
#' nxn correlation matrix.
#' @param log_out
#' integer; probability or log of probability? 
#' @return 
#' double; (log of) probability. 
#' @keywords internal
#'
TVBS_v2 <- function(x_norm, Cor_mat, log_out = 0L) {
    .Call(`_Rprobit_TVBS_v2`, x_norm, Cor_mat, log_out)
}

#' TVBS approximation to multivariate Gaussian CDF. 
#' @description
#' The function computes the  CDF for a multivariate Gaussian distribution according to the method of Chandra Bhat (TVBS). 
#' @param x_norm
#' nx1 vector of point to evaluate the CDF at. 
#' @param Cor_mat
#' nxn correlation matrix.
#' @param log_out
#' integer; probability or log of probability? 
#' @return 
#' double; (log of) probability. 
#' @keywords internal
#'
TVBS_pv2 <- function(x_norm, Cor_mat, log_out = 0L) {
    .Call(`_Rprobit_TVBS_pv2`, x_norm, Cor_mat, log_out)
}

#' TVBS approximation to multivariate Gaussian CDF: calculates CDF and gradient. 
#' @description
#' The function computes the  CDF and the corresponding gradient for a multivariate Gaussian distribution according to the method of Chandra Bhat (TVBS). 
#' @param x_norm
#' nx1 vector of point to evaluate the CDF at. 
#' @param Cor_mat
#' nxn correlation matrix.
#' @param log_out
#' integer; probability or log of probability? 
#' @return 
#' vector; gradient of log probability, double; (log of) probability.
#' @keywords internal  
#'
TVBS_grad <- function(x_norm, Cor_mat, log_out = 0L) {
    .Call(`_Rprobit_TVBS_grad`, x_norm, Cor_mat, log_out)
}

#' TVBS approximation to multivariate Gaussian CDF: calculates Hessian of log CDF 
#' @description
#' The function computes the Hessian of the log of the CDF and the corresponding gradient for a multivariate Gaussian distribution according to the method of Chandra Bhat (TVBS). 
#' @param x_norm
#' nx1 vector of point to evaluate the CDF at. 
#' @param Cor_mat
#' nxn correlation matrix.
#' @return 
#' matrix; Hessian of log probability. 
#' @keywords internal 
#'
TVBS_hess_new <- function(x_norm, Cor_mat) {
    .Call(`_Rprobit_TVBS_hess_new`, x_norm, Cor_mat)
}

#' Calculation of Approximated Composite Marginal Likelihood
#'
#' @description
#' This function computes the composite marginal likelihood.
#'
#' @param theta
#' parameter vector
#' @param data_obj
#' data_cl object
#' @param mod
#' A \code{\link{mod_cl}} object.
#' @param control
#' Controls for the probit estimation.
#'
#' @return
#' A vector, containing the negative log-likelihood with attributes containing the gradient and (if specified in the controls) the Hessian.
#'
#' @export
#'
ll_macml <- function(theta, data_obj, mod, control) {
    .Call(`_Rprobit_ll_macml`, theta, data_obj, mod, control)
}

#' Calculation of of approximated probit log likelihood calculation.
#' @description
#' Computes the log likelihood.
#' @param theta
#' parameter vector
#' @param data_obj
#' \link{data_cl} object
#' @param mod
#' A \code{\link{mod_cl}} object.
#' @param control
#' Controls for the probit estimation.
#' @return
#' A vector, containing the negative log-likelihood with attributes containing the gradient and (if specified in the controls) the Hessian.
#' @export
#'
ll_probit <- function(theta, data_obj, mod, control) {
    .Call(`_Rprobit_ll_probit`, theta, data_obj, mod, control)
}

#' Choice probabilities for probit models
#' @description
#' Computes the approximate choice porbabilities for the probit case.
#' @param theta
#' parameter vector
#' @param data
#' data list
#' @param mod
#' A \code{\link{mod_cl}} object.
#' @param control
#' Controls for the probit estimation.
#' @return
#' A vector, containing the negative log-likelihood with attributes containing the gradient and (if specified in the controls) the Hessian.
#' @keywords internal
#'
pred_probit_approx <- function(theta, data, mod, control) {
    .Call(`_Rprobit_pred_probit_approx`, theta, data, mod, control)
}

#' providing categories for integers for cycling through upper and lower bounds
#' @description
#' converts integers into vector of category indices
#' @param num
#' integer index
#' @param cat
#' number of alternatives
#' @param noBits
#' integer number of bits
#' @return
#' vector of categories
#' @keywords internal
#'
int2cats <- function(num, cat, noBits) {
    .Call(`_Rprobit_int2cats`, num, cat, noBits)
}

#' Calculation of contribution of one person to the approximated probit log likelihood calculation.
#' @description
#' Computes the contribution of one person to the log likelihood.
#' @param X_n
#' X list of regressor matrices
#' @param theta
#' parameter vector
#' @param mod
#' A \code{\link{mod_cl}} object.
#' @param pairwise
#' integer specifying the pairwise option
#' @param approx_method
#' string specifying the approx_method
#' @return
#' A vector, containing the negative log-likelihood with attributes containing the gradient and (if specified in the controls) the Hessian.
#' @keywords internal
#'
ll_probit_person <- function(X_n, theta, mod, pairwise, approx_method) {
    .Call(`_Rprobit_ll_probit_person`, X_n, theta, mod, pairwise, approx_method)
}

#' Calculation of contribution of one person to the approximated probit log likelihood calculation.
#' @description
#' Computes the contribution of one person to the log likelihood.
#' @param X_n
#' X_n list of regressor matrices
#' @param y_n
#' vector of choices
#' @param theta
#' parameter vector
#' @param mod
#' A \code{\link{mod_cl}} object.
#' @param approx_method
#' string specifying the approximation method
#' @return
#' A vector, containing the negative log-likelihood with attributes containing the gradient and (if specified in the controls) the Hessian.
#' @keywords internal
#'
ll_probit_contrib_R <- function(X_n, y_n, theta, mod, approx_method) {
    .Call(`_Rprobit_ll_probit_contrib_R`, X_n, y_n, theta, mod, approx_method)
}

#' Calculation of the normalizing factor for the approximated composite likelihood calculation.
#' @description
#' Computes the norming factor for the CML.
#' @param theta
#' parameter vector
#' @param data_obj
#' \link{data_cl} object
#' @param mod
#' A \code{\link{mod_cl}} object.
#' @param control
#' Controls for the probit estimation.
#' @return
#' A vector, containing the negative log-likelihood norming factor.
#' @keywords internal
#'
ll_macml_norm_factor <- function(theta, data_obj, mod, control) {
    .Call(`_Rprobit_ll_macml_norm_factor`, theta, data_obj, mod, control)
}

#' Calculation of of approximated composite likelihood (including norming)
#' @description
#' Computes the CML.
#' @param theta
#' parameter vector
#' @param data_obj
#' \link{data_cl} object
#' @param mod
#' A \code{\link{mod_cl}} object.
#' @param control
#' Controls for the probit estimation.
#' @return
#' A vector, containing the negative log-likelihood with attributes containing the gradient and (if specified in the controls) the Hessian.
#' @keywords internal
#'
ll_macml_norm <- function(theta, data_obj, mod, control) {
    .Call(`_Rprobit_ll_macml_norm`, theta, data_obj, mod, control)
}

#' generate identity matrix of size 'alt' that adds a zero y'th row.
#' @description
#' generate identity matrix of size 'alt' that adds a zero y'th row.
#' @param y
#' integer; row to zero out
#' @param alt
#' integer; numbre of alternatives
#' @return
#' matrix; altxalt
#' @keywords internal
makeAM <- function(y, alt) {
    .Call(`_Rprobit_makeAM`, y, alt)
}

#' Calculation of of approximated composite likelihood calculation.
#' @description
#' Computes the CML.
#' @param theta
#' parameter vector
#' @param data_obj
#' \link{data_cl} object
#' @param mod
#' A \code{\link{mod_cl}} object.
#' @param control
#' Controls for the probit estimation.
#' @return
#' A vector, containing the negative log-likelihood with attributes containing the gradient and (if specified in the controls) the Hessian.
#' @keywords internal
#'
ll_macml_norm_est <- function(theta, data_obj, mod, control) {
    .Call(`_Rprobit_ll_macml_norm_est`, theta, data_obj, mod, control)
}

#' MACML function for ordered probit models
#' @description
#' Computes the approximate composite likelihood for the ordered probit case.
#' @param theta
#' parameter vector
#' @param data_obj
#' \link{data_cl} organised as a data_cl object containing (a) list with elements contains the nxk matrix X and the nx1 vector y (b) N number of deciders (c) number of choice situations per decider
#' @param mod
#' A \code{\link{mod_cl}} object.
#' @param control
#' Controls for the ordered probit estimation.
#' @return
#' A vector, containing the negative log-likelihood with attributes containing the gradient and (if specified in the controls) the Hessian.
#' @export
#'
ll_macml_o <- function(theta, data_obj, mod, control) {
    .Call(`_Rprobit_ll_macml_o`, theta, data_obj, mod, control)
}

#' Probability to multivariate ordered probit model.
#' @description
#' The function computes the probability of a number of choices in repeated ordered probit choices.
#' @param xb
#' nx1 vector of systematic part
#' @param y_n
#' nx1 integer vector of choices.
#' @param Lambda
#' Covariance matrix for random utilities including the random coefficients.
#' @param alt
#' integer; number of choice alternatives.
#' @param dtauk
#' (alt-1) real vector of increments of category limits obtained as the cumulative sum of the vector.
#' @param approx_method
#' string: approximation method, either "SJ" or "ME"
#' @return
#' double; log of probability.
#' @keywords internal
#' 
prob_ordered <- function(xb, y_n, Lambda, alt, dtauk, approx_method) {
    .Call(`_Rprobit_prob_ordered`, xb, y_n, Lambda, alt, dtauk, approx_method)
}

#' Choice probabilities for ordered probit models
#' @description
#' Computes the approximate choice probabilities for the ordered probit case.
#' @param theta
#' parameter vector
#' @param Xn
#' matrix of regressors
#' @param yn
#' vector of responses
#' @param mod
#' A \code{\link{mod_cl}} object.
#' @return
#' A matrix, containing the predicted choice probabilities for each choice marginally (ignoring correlations)
#' @export
#'
pred_probit_ordered_approx <- function(theta, Xn, yn, mod) {
    .Call(`_Rprobit_pred_probit_ordered_approx`, theta, Xn, yn, mod)
}

#' Hess_pdf
#' @description
#' The function computes the Hessian of the bivariate Gaussian CDF. 
#' @param w0
#' double; x-coordinate 
#' @param w1
#' double; y-coordinate 
#' @param rho
#' double; correlation
#' @return 
#' matrix; Hessian of pdf 
#' @keywords internal
#'
Hess_pdf <- function(w0, w1, rho) {
    .Call(`_Rprobit_Hess_pdf`, w0, w1, rho)
}

#' general bivariate normal cdf calculation 
#' @description
#' The function computes the bivariate Gaussian CDF. 
#' @param b
#' vector; point to evaluate CDF 
#' @param Sigma
#' 2x2 matrix; variance matrix.
#' @return 
#' double; CDF
#' @keywords internal 
biv_gen_cdf <- function(b, Sigma) {
    .Call(`_Rprobit_biv_gen_cdf`, b, Sigma)
}

#' general bivariate normal gradient cdf calculation 
#' @description
#' The function computes the gradient of the bivariate Gaussian CDF. 
#' @param b
#' vector; point to evaluate CDF 
#' @param Sigma
#' 2x2 matrix; variance matrix.
#' @return 
#' vector; gradient of CDF
#' @keywords internal 
grad_gen_cdf <- function(b, Sigma) {
    .Call(`_Rprobit_grad_gen_cdf`, b, Sigma)
}

#' general bivariate normal Hessian of cdf calculation 
#' @description
#' The function computes the Hessian of the bivariate Gaussian CDF. 
#' @param b
#' vector; point to evaluate CDF 
#' @param Sigma
#' 2x2 matrix; variance matrix.
#' @return 
#' 5x5 matrix; Hessian of CDF 
#' @keywords internal
Hess_gen_cdf <- function(b, Sigma) {
    .Call(`_Rprobit_Hess_gen_cdf`, b, Sigma)
}

#' general trivariate normal cdf calculation 
#' @description
#' The function computes the gradient of the trivariate Gaussian CDF. 
#' @param b
#' vector; point to evaluate CDF 
#' @param Sigma
#' 3x3 matrix; variance matrix.
#' @return 
#' 9x1; gradient of the CDF 
#' @keywords internal 
grad_gen_tvn_cdf <- function(b, Sigma) {
    .Call(`_Rprobit_grad_gen_tvn_cdf`, b, Sigma)
}

#' general trivariate normal cdf calculation 
#' @description
#' The function computes the Hessian of the trivariate Gaussian CDF. 
#' @param b
#' vector; point to evaluate CDF 
#' @param Sigma
#' 3x3 matrix; variance matrix.
#' @return 
#' 9x9; Hessian of the CDF 
#' @keywords internal 
Hessian_gen_tvn_cdf <- function(b, Sigma) {
    .Call(`_Rprobit_Hessian_gen_tvn_cdf`, b, Sigma)
}

#' duplication matrix
#' @description
#' Computes the duplication matrix converting from vech to vec..
#' @param n
#' integer; dimension of matrix.
#' @return 
#' matrix
#' @keywords internal 
#'
duplmat <- function(n) {
    .Call(`_Rprobit_duplmat`, n)
}

#' vech indices
#' @description
#' Returns indices of vech(X) w.r.t to the entries of X WITHOUT THE DIAGONAL
#' @param k
#' integer; dimension of matrix.
#' @return 
#' matrix
#' @keywords internal 
#'
vechor <- function(k) {
    .Call(`_Rprobit_vechor`, k)
}

#' indices of diagonal elements in vectorized kxk square matrix.
#' @description
#' Returns indices of diagonal elements in vectorized kxk square matrix.
#' @param k
#' integer; dimension of matrix.
#' @return 
#' matrix
#' @keywords internal 
#'
fdiag <- function(k) {
    .Call(`_Rprobit_fdiag`, k)
}

#' Returns indices of vech(X) w.r.t to the entries of X
#' @description
#' Returns indices of vech(X) w.r.t to the entries of X
#' @param k
#' integer; dimension of matrix.
#' @return 
#' matrix
#' @keywords internal 
#'
vechor_diag <- function(k) {
    .Call(`_Rprobit_vechor_diag`, k)
}

#' Returns commutation matrix such that C vec(X) = vec(X')
#' @description
#' Returns commutation matrix such that C vec(X) = vec(X')
#' @param r
#' integer; number of rows in the matrix.
#' @param c
#' integer; number of columns in matrix.
#' @return 
#' matrix
#' @keywords internal 
#'
commmat <- function(r, c) {
    .Call(`_Rprobit_commmat`, r, c)
}

#' Returns elimination matrix such that C vec(X) = vech(X)
#' @description
#' Returns elimination matrix such that C vec(X) = vech(X)
#' @param n
#' integer; dimension of matrix.
#' @return 
#' matrix
#' @keywords internal 
#'
elimmat <- function(n) {
    .Call(`_Rprobit_elimmat`, n)
}

#' returns the dvech(LL')/dvech(L)
#' @description
#' Returns the Jacobian of the matrix-vectorization with respect to the vech of the Cholesky factor  
#' @param x
#' real vector of vectorization of lower triangular of Cholesky factor 
#' @return 
#' Jacobian matrix
#' @keywords internal 
#'
J_chol <- function(x) {
    .Call(`_Rprobit_J_chol`, x)
}

#' calculates the probability of pair of choices in an ordered probit model
#' @description
#' calculates the probability of pair of choices in an ordered probit model
#' @param xb
#' vector of systematic utilities
#' @param y
#' vector of choices
#' @param Lambda 
#' correlation matrix
#' @param alt
#' integer; number of alternatives
#' @param dtauk
#' vector of category limits. 
#' @return 
#' matrix
#' @keywords internal
#'
prob_ordered_2 <- function(xb, y, Lambda, alt, dtauk) {
    .Call(`_Rprobit_prob_ordered_2`, xb, y, Lambda, alt, dtauk)
}

#' calculates the CML of a number of choices in an ordered probit model
#' @description
#' calculates the CML of a number of choices in an ordered probit model
#' @param xb
#' vector of systematic utilities
#' @param y
#' vector of choices
#' @param Lambda 
#' correlation matrix
#' @param alt
#' integer; number of alternatives
#' @param dtauk
#' vector of category limits. 
#' @param cml_pair_type
#' integer; indicating pair type structure
#' @return 
#' matrix
#' @keywords internal
#'
prob_ordered_CML <- function(xb, y, Lambda, alt, dtauk, cml_pair_type) {
    .Call(`_Rprobit_prob_ordered_CML`, xb, y, Lambda, alt, dtauk, cml_pair_type)
}

#' calculates the probability of one choice in an ordered probit model
#' @description
#' calculates the probability of one choice in an ordered probit model
#' @param xb
#' real; systematic utility
#' @param y1
#' integer; choice
#' @param Lambda 
#' real; variance
#' @param alt
#' integer; number of alternatives
#' @param dtauk
#' vector of category limits. 
#' @return 
#' matrix
#' @keywords internal
#'
prob_ordered_1 <- function(xb, y1, Lambda, alt, dtauk) {
    .Call(`_Rprobit_prob_ordered_1`, xb, y1, Lambda, alt, dtauk)
}

